import { CustomButton } from '@/components/Common/Button';
import { ToastifyService } from '@/components/Toastify/toastifyService';
import { ArrowForward } from '@mui/icons-material';
import { Box, Step, StepLabel, Stepper } from '@mui/material';
import { useFormik } from 'formik';
import { useEffect, useState } from 'react';
import {
  STEP_FIELDS,
  initialValues,
  validationSchemas,
  getValidationSchemaForStep,
  stepFormConfigs,
} from './Config/formConfig';
import OnBoardingPermohonan from './OnBoarding';
import IdentitasPemberi from './view/IdentitasPemberi';
import IdentitasPenerima from './view/IdentitasPenerima';
import InformasiJaminan from './view/InformasiJaminan';
import ObyekJaminan from './view/ObyekJaminan';
import KonfirmasiDataDetail from './view/KonfirmasiData';
import PembayaranPage from './view/Pembayaran';
import SuccessPage from './view/SuccessPage';
import { cleanPayloadAdvanced } from '../helpers/cleanPayload';
import FidusiaPendaftarService from '@/services/fidusia/FidusiaPendaftarServices';
import {
  setNestedTouched,
  validateCurrentStep,
} from '../helpers/formikHelpers';

export default function FormPendaftaranFidusia({
  label = 'Permohonan Pendaftaran Fidusia',
}) {
  const [activeStep, setActiveStep] = useState(0);
  const [skipped, setSkipped] = useState(new Set());
  const [stepErrors, setStepErrors] = useState({});
  const [completedSteps, setCompletedSteps] = useState(new Set());
  const toastifyService = new ToastifyService();
  const isStepSkipped = (step) => skipped.has(step);
  const [loading, setLoading] = useState(false);

  const formik = useFormik({
    validateOnBlur: true,
    validateOnChange: true,
    validateOnMount: false,
    initialValues: initialValues,
    validationSchema: () => {
      return getValidationSchemaForStep(activeStep);
    },
    onSubmit: (values) => {
      console.log('ðŸš€ ~ Pendaftaran ~ values:', values);
      toastifyService.confirmationCreate().then((res) => {
        if (res) {
          const payload = { ...values };
          console.log('payload', payload);
          toastifyService.customWarningMsg('API Belum tersedia');
        }
      });
    },
  });

  useEffect(() => {
    setActiveStep(1);
    formik.resetForm();
    setStepErrors({});
    setCompletedSteps(new Set());
  }, [label]);

  // const setNestedTouched = (formik, errors) => {
  //   const newTouched = { ...formik.touched };

  //   const markNestedTouched = (errorObj, currentPath = '') => {
  //     Object.keys(errorObj).forEach((key) => {
  //       const fullPath = currentPath ? `${currentPath}.${key}` : key;

  //       if (typeof errorObj[key] === 'object' && errorObj[key] !== null) {
  //         // Jika masih berbentuk objek (nested), rekursif
  //         if (!newTouched[key]) {
  //           newTouched[key] = {};
  //         }
  //         markNestedTouched(errorObj[key], fullPath);
  //       } else {
  //         // Jika sudah leaf node, set touched
  //         if (currentPath) {
  //           const [parent, child] = fullPath.split('.');
  //           if (!newTouched[parent]) {
  //             newTouched[parent] = {};
  //           }
  //           newTouched[parent][child] = true;
  //         } else {
  //           newTouched[key] = true;
  //         }
  //       }
  //     });
  //   };

  //   // Proses marking touched untuk semua error
  //   markNestedTouched(errors);

  //   // Set touched di formik
  //   formik.setTouched(newTouched, true);
  // };

  // const validateCurrentStep = async () => {
  //   const currentSchema = validationSchemas[activeStep];
  //   const currentStepFields = STEP_FIELDS[activeStep];

  //   if (!currentSchema) return { isValid: true, errors: {} };

  //   // Trigger validasi
  //   const errors = await formik.validateForm();

  //   // Kumpulkan error spesifik untuk step saat ini
  //   const stepErrors = {};
  //   currentStepFields.forEach((field) => {
  //     if (field.includes('.')) {
  //       const [parent, child] = field.split('.');

  //       // Cek error nested
  //       if (errors[parent] && errors[parent][child]) {
  //         if (!stepErrors[parent]) {
  //           stepErrors[parent] = {};
  //         }
  //         stepErrors[parent][child] = errors[parent][child];
  //       }
  //     } else {
  //       if (errors[field]) {
  //         stepErrors[field] = errors[field];
  //       }
  //     }
  //   });

  //   // Tentukan hasil validasi
  //   if (Object.keys(stepErrors).length > 0) {
  //     // Set error di Formik
  //     formik.setErrors({
  //       ...formik.errors,
  //       ...stepErrors,
  //     });

  //     return {
  //       isValid: false,
  //       errors: stepErrors,
  //     };
  //   }

  //   return { isValid: true, errors: {} };
  // };

  const handleFetchForStep = async (activeStep, formik) => {
    // Map active step to corresponding API method and data
    const stepApiMap = {
      1: {
        apiMethod: FidusiaPendaftarService.postFidusiaPendaftaranPemberi,
        data: cleanPayloadAdvanced(formik.values.identity_pemberi),
      },
      2: {
        apiMethod: FidusiaPendaftarService.postFidusiaPendaftaranPenerima,
        data: cleanPayloadAdvanced(formik.values.identity_penerima),
      },
      // Extend this map for more steps as needed
    };

    const currentStepDetails = stepApiMap[activeStep];

    // If there's a corresponding API method for the current step
    if (currentStepDetails) {
      const { apiMethod, data } = currentStepDetails;
      try {
        // Await the API call and get the response
        const response = await apiMethod(data); // Assume this returns the response
        return response; // Return the API response for further processing
      } catch (error) {
        // Handle API error
        console.error('Error submitting data:', error);
        throw error; // Rethrow error to handle it in the main function
      }
    }

    return null; // Default return if no API method found for the step
  };

  const handleNext = async () => {
    try {
      // Trigger validation for the current step
      // const validation = await validateCurrentStep();
      const validation = await validateCurrentStep(
        formik,
        activeStep,
        validationSchemas,
        STEP_FIELDS
      );

      if (validation.isValid) {
        setLoading(true);
        const response = await handleFetchForStep(activeStep, formik);

        if (response) {
          localStorage.setItem(
            'id_pendaftaran',
            JSON.stringify(response.data?.id_pendaftaran)
          );

          setLoading(false);

          // Clear any errors for the current step
          const newStepErrors = { ...stepErrors };
          delete newStepErrors[activeStep];
          setStepErrors(newStepErrors);

          // Mark current step as completed
          setCompletedSteps((prev) => new Set([...prev, activeStep]));

          // Move to the next step
          setActiveStep((prevActiveStep) => prevActiveStep + 1);

          // Update skipped steps
          setSkipped((prevSkipped) => {
            const newSkipped = new Set(prevSkipped.values());
            newSkipped.delete(activeStep);
            return newSkipped;
          });

          console.log(
            `Values Step ${activeStep}:`,
            response // Log the actual response for better debugging
          );
        }
      } else {
        setLoading(false);
        // If invalid, set touched for errors
        setNestedTouched(formik, validation.errors);

        // Store errors for the current step
        setStepErrors((prev) => ({
          ...prev,
          [activeStep]: validation.errors,
        }));
      }
    } catch (error) {
      console.error('Validation error:', error);
    }
  };

  // const handleNext = async () => {
  //   try {
  //     // Trigger validation for the current step
  //     const validation = await validateCurrentStep();
  //     console.log('validation>>', validation);

  //     if (validation.isValid) {
  //       // Ambil value berdasarkan step
  //       const stepValues = {
  //         1: cleanPayloadAdvanced(formik.values.identity_pemberi),
  //         2: cleanPayloadAdvanced(formik.values.identity_penerima),
  //         3: formik.values.jaminan,

  //         // Tambahkan step lainnya
  //       };

  //       // Akses value spesifik step
  //       const currentStepValues = stepValues[activeStep];

  //       // Lakukan sesuatu dengan values step

  //       // Jika valid, hapus error untuk step saat ini
  //       const newStepErrors = { ...stepErrors };
  //       delete newStepErrors[activeStep];
  //       setStepErrors(newStepErrors);

  //       // Tandai step sebagai selesai
  //       setCompletedSteps((prev) => new Set([...prev, activeStep]));

  //       // Pindah ke step berikutnya
  //       setActiveStep((prevActiveStep) => prevActiveStep + 1);

  //       // Perbarui skipped steps
  //       setSkipped((prevSkipped) => {
  //         const newSkipped = new Set(prevSkipped.values());
  //         newSkipped.delete(activeStep);
  //         return newSkipped;
  //       });
  //       console.log(`Values Step ${activeStep}:`, currentStepValues);
  //     } else {
  //       // Jika tidak valid, set touched untuk error
  //       setNestedTouched(formik, validation.errors);

  //       // Simpan error step
  //       setStepErrors((prev) => ({
  //         ...prev,
  //         [activeStep]: validation.errors,
  //       }));
  //     }
  //   } catch (error) {
  //     console.error('Validation error:', error);
  //   }
  // };

  const handleSubmit = async (status) => {
    // Validate all steps before submit
    let hasErrors = false;
    const allStepErrors = {};

    for (let i = 0; i < STEP_FIELDS.length; i++) {
      const stepSchema = validationSchemas[i];
      const stepFieldsList = STEP_FIELDS[i];

      if (!stepSchema) continue;

      try {
        const stepValues = stepFieldsList.reduce((acc, field) => {
          acc[field] = formik.values[field];
          return acc;
        }, {});

        await stepSchema.validate(stepValues, { abortEarly: false });
      } catch (error) {
        hasErrors = true;
        const fieldErrors = {};
        if (error.inner) {
          error.inner.forEach((err) => {
            fieldErrors[err.path] = err.message;
          });
        }
        allStepErrors[i] = fieldErrors;
      }
    }

    console.log('allStepErrors', allStepErrors);

    if (!hasErrors) {
      formik.setFieldValue('status', status);
      formik.submitForm();
    } else {
      setStepErrors(allStepErrors);

      // Set all field errors to formik
      const allFieldErrors = {};
      Object.values(allStepErrors).forEach((stepError) => {
        Object.assign(allFieldErrors, stepError);
      });

      formik.setErrors(allFieldErrors);

      // Mark all fields as touched
      const allFields = STEP_FIELDS.flat();
      const touchedFields = allFields.reduce((acc, field) => {
        acc[field] = true;
        return acc;
      }, {});

      formik.setTouched(touchedFields);

      toastifyService.customWarningMsg(
        'Terdapat kesalahan pada form. Mohon periksa kembali.'
      );

      const firstErrorStep = Object.keys(allStepErrors)[1];
      if (firstErrorStep) {
        setActiveStep(parseInt(firstErrorStep));
      }
    }
  };

  const allSteps = [
    {
      id: '1',
      label: 'Boarding',
      component: (
        <OnBoardingPermohonan
          formik={formik}
          setActiveStep={setActiveStep}
          label={label}
        />
      ),
    },
    {
      id: '2',
      label: 'Identitas Pemberi',
      stepNumber: 'Langkah 1',
      component: <IdentitasPemberi formik={formik} />,
    },
    {
      id: '3',
      label: 'Identitas Penerima',
      stepNumber: 'Langkah 2',
      component: <IdentitasPenerima formik={formik} />,
    },
    {
      id: '4',
      label: 'Informasi Jaminan',
      stepNumber: 'Langkah 3',
      component: <InformasiJaminan formik={formik} />,
    },
    {
      id: '5',
      label: 'Obyek Jaminan',
      stepNumber: 'Langkah 4',
      component: <ObyekJaminan formik={formik} />,
    },
    {
      id: '6',
      label: 'Konfirmasi Data',
      stepNumber: 'Langkah 5',
      component: (
        <KonfirmasiDataDetail formik={formik} setActiveStep={setActiveStep} />
      ),
    },
    {
      id: '7',
      label: 'Pembayaran',
      stepNumber: 'Langkah 6',
      component: <PembayaranPage formik={formik} />,
    },
    {
      id: '8',
      label: 'Success',
      stepNumber: 'Langkah 7',
      component: <SuccessPage formik={formik} />,
    },
  ];

  const stepsConfig = {
    'Permohonan Pendaftaran Fidusia': ['1', '2', '3', '4', '5', '6', '7', '8'],
  };

  const activeStepIds = stepsConfig[label] || [];
  const stepsResult = allSteps.filter((step) =>
    activeStepIds.includes(step.id)
  );

  const visibleStepperSteps = stepsResult.filter((s) => s.stepNumber);
  const stepperActiveStep = visibleStepperSteps.findIndex(
    (s) => s.id === stepsResult[activeStep]?.id
  );

  const handleBack = () => {
    setActiveStep((prevActiveStep) => prevActiveStep - 1);
  };

  return (
    <Box className="bg-white page-content mb-4" sx={{ width: '100%' }}>
      {/* Page title */}
      {visibleStepperSteps.length > 0 && stepperActiveStep >= 0 && (
        <h3
          className=" mb-4"
          style={{ fontWeight: 500, fontSize: 24, color: '#262626' }}
        >
          Formulir Pendaftaran
        </h3>
      )}
      {/* Stepper */}
      {visibleStepperSteps.length > 0 && stepperActiveStep >= 0 && (
        <Stepper
          activeStep={stepperActiveStep}
          alternativeLabel
          // connector={<CustomStepConnector />}
          sx={{
            '& .MuiStepConnector-root': {
              top: 10,
              left: 'calc(-50% + 16px)',
              right: 'calc(50% + 16px)',
            },
            '& .MuiStepConnector-line': {
              borderTopStyle: 'dashed',
              borderTopWidth: 2,
              color: '#E7E7E7',
            },
          }}
        >
          {visibleStepperSteps.map((step, index) => {
            if (isStepSkipped(index)) {
              stepProps.completed = false;
            }
            return (
              <Step key={step.id}>
                <StepLabel
                  StepIconComponent={({ active, completed }) => (
                    <div
                      style={{
                        width: 24,
                        height: 24,
                        borderRadius: '50%',
                        border: '1px solid #E7E7E7',
                        backgroundColor:
                          active || completed ? '#041662' : '#fff',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        color: active || completed ? '#fff' : '#041662',
                        transition: 'all 0.3s ease',
                      }}
                    >
                      {index + 1}
                    </div>
                  )}
                >
                  <span
                    style={{
                      fontFamily: 'Poppins',
                      fontWeight: 400,
                      fontSize: '12px',
                      lineHeight: '18px',
                      color: '#888888',
                    }}
                  >
                    {step.label}
                  </span>
                </StepLabel>
              </Step>
            );
          })}
        </Stepper>
      )}
      {/* Step content */}
      <>
        <div className="mt-5 mb-3 px-2">
          <Box
            sx={{ border: '1px solid #E7E7E7', borderRadius: 5, padding: 2 }}
          >
            {stepsResult[activeStep]?.component || 'Unknown step'}

            {activeStep >= 1 && (
              <Box
                sx={{
                  display: 'flex',
                  flexDirection: 'row',
                  justifyContent: 'flex-end',
                  pt: 2,
                  px: 2,
                }}
              >
                <CustomButton
                  text={'Kembali'}
                  bgColor="transparent"
                  border="1px solid #E7E7E7"
                  textColor="#041662"
                  disabled={activeStep === 0}
                  onClick={handleBack}
                />
                <CustomButton
                  text={'Simpan Draft'}
                  bgColor="#f97316"
                  border="1px solid #E7E7E7"
                  textColor="#fff"
                  hoverColor="#ea580c"
                  disabled={activeStep === 0}
                  onClick={() => handleSubmit('draf')}
                />
                <CustomButton
                  loading={loading}
                  onClick={() => {
                    if (activeStep === stepsResult.length - 1) {
                      handleSubmit('submit');
                    } else {
                      handleNext();
                    }
                  }}
                  text={
                    activeStep === stepsResult.length - 1
                      ? 'Selesai'
                      : 'Selanjutnya'
                  }
                  rightIcon={<ArrowForward fontSize="14" />}
                />
              </Box>
            )}
          </Box>
        </div>
      </>
    </Box>
  );
}
